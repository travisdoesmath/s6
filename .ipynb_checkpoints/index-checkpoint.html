<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>S6 Automorphism Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chosen Palette: Slate & Amber -->
    <!-- Application Structure Plan: A single, large canvas element is the centerpiece. The user flow is simple: 1. Observe the complete graph K6. 2. Move the mouse over any edge. 3. Instantly see the highlighted result of the automorphism on that edge. This structure is the most direct and effective way to visualize the mapping relationship, which is the sole purpose of this tool. No complex UI is needed; the interaction is the visualization itself. -->
    <!-- Visualization & Content Choices: Report Info -> Goal -> Viz/Presentation -> Interaction -> Justification. 1. The Automorphism Map -> Relate/Organize -> Interactive Canvas Graph -> Hovering over an edge -> This provides a direct, one-to-one visual mapping between a cause (a single transposition) and its effect (a triple transposition). Using a graph is the natural mathematical way to represent relationships between pairs of elements. Highlighting on hover is an intuitive and immediate form of feedback. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap');
        body {
            font-family: 'Roboto', sans-serif;
            background-color: #1e293b; /* slate-800 */
            color: #f1f5f9; /* slate-100 */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
        }
        canvas {
            background-color: #0f172a; /* slate-900 */
            border-radius: 0.5rem;
            border: 1px solid #334155;
        }
    </style>
</head>
<body class="p-4">

    <div class="w-full max-w-2xl text-center">
        <header class="mb-4">
            <h1 class="text-3xl sm:text-4xl font-bold">S6 Automorphism Visualizer</h1>
            <p class="text-slate-300 mt-1">Hover over an edge to see its image under the outer automorphism.</p>
        </header>
        <div class="chart-container" style="position: relative; width: 100%; max-width: 600px; margin: auto; aspect-ratio: 1/1;">
             <canvas id="graphCanvas"></canvas>
        </div>
        <div id="info-panel" class="mt-4 h-12 text-lg text-amber-300 font-mono"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('graphCanvas');
            const ctx = canvas.getContext('2d');
            const infoPanel = document.getElementById('info-panel');

            // Helper for permutation mathematics
            const Permutation = {
                fromCycles(cycles, size = 6) {
                    const p = Array.from({ length: size }, (_, i) => i);
                    cycles.forEach(cycle => {
                        for (let i = 0; i < cycle.length; i++) {
                            const current = cycle[i];
                            const next = cycle[(i + 1) % cycle.length];
                            p[current] = next;
                        }
                    });
                    return p;
                },
                toCycles(p) {
                    const cycles = [];
                    const visited = new Array(p.length).fill(false);
                    for (let i = 0; i < p.length; i++) {
                        if (!visited[i]) {
                            const cycle = [];
                            let j = i;
                            while (!visited[j]) {
                                visited[j] = true;
                                cycle.push(j);
                                j = p[j];
                            }
                            if (cycle.length > 1) {
                                cycles.push(cycle);
                            }
                        }
                    }
                    return cycles;
                },
                compose(p1, p2) {
                    const result = new Array(p1.length);
                    for (let i = 0; i < p1.length; i++) {
                        result[i] = p1[p2[i]];
                    }
                    return result;
                },
                inverse(p) {
                    const inv = new Array(p.length);
                    for (let i = 0; i < p.length; i++) {
                        inv[p[i]] = i;
                    }
                    return inv;
                },
                conjugate(p, h) {
                    const p_inv = this.inverse(p);
                    return this.compose(p, this.compose(h, p_inv));
                }
            };
            
            // Generates the full map based on the definition φ((1...5))=(1...5) and φ((1 6))=(1 6)(2 5)(3 4)
            function generateAutomorphismMap() {
                const g = Permutation.fromCycles([[0, 1, 2, 3, 4]]);
                const t = Permutation.fromCycles([[0, 5]]);
                
                const phi_g = Permutation.fromCycles([[0, 1, 2, 3, 4]]);
                const phi_t = Permutation.fromCycles([[0, 5], [1, 4], [2, 3]]);

                const map = {};
                const phi_map_perms = {};

                // 1. Derive images for transpositions involving 6, e.g., (2 6), (3 6), etc.
                // by conjugating (1 6) with powers of (1 2 3 4 5).
                // φ(g*t*g⁻¹) = φ(g)*φ(t)*φ(g)⁻¹
                let g_power = Permutation.fromCycles([]); // identity
                let phi_g_power = Permutation.fromCycles([]); // identity
                for (let i = 0; i < 5; i++) {
                    const current_t = Permutation.conjugate(g_power, t);
                    const phi_current_t = Permutation.conjugate(phi_g_power, phi_t);
                    
                    const key = Permutation.toCycles(current_t)[0].sort((a, b) => a - b).join(',');
                    phi_map_perms[key] = phi_current_t;
                    map[key] = Permutation.toCycles(phi_current_t);

                    g_power = Permutation.compose(g, g_power);
                    phi_g_power = Permutation.compose(phi_g, phi_g_power);
                }

                // 2. Derive images for transpositions not involving 6, e.g., (1 2), (3 4), etc.
                // using the identity (i j) = (i 6)(j 6)(i 6).
                // φ((i j)) = φ((i 6)) * φ((j 6)) * φ((i 6))
                for (let i = 0; i < 5; i++) {
                    for (let j = i + 1; j < 5; j++) {
                        const key_ij = `${i},${j}`;
                        const key_i6 = `${i},5`;
                        const key_j6 = `${j},5`;

                        const phi_i6 = phi_map_perms[key_i6];
                        const phi_j6 = phi_map_perms[key_j6];
                        
                        const phi_ij = Permutation.compose(phi_i6, Permutation.compose(phi_j6, phi_i6));
                        map[key_ij] = Permutation.toCycles(phi_ij);
                    }
                }
                return map;
            }

            const automorphismMap = generateAutomorphismMap();
            let vertices = [];
            let edges = [];
            let hoveredEdge = null;

            function setup() {
                const container = canvas.parentElement;
                const size = Math.min(container.clientWidth, container.clientHeight);
                canvas.width = size;
                canvas.height = size;
                
                vertices = [];
                const radius = size * 0.4;
                const center = { x: size / 2, y: size / 2 };

                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * 2 * Math.PI - Math.PI / 2;
                    vertices.push({
                        x: center.x + radius * Math.cos(angle),
                        y: center.y + radius * Math.sin(angle),
                        label: i + 1
                    });
                }

                edges = [];
                for (let i = 0; i < 6; i++) {
                    for (let j = i + 1; j < 6; j++) {
                        edges.push({ v1: i, v2: j });
                    }
                }
                
                draw();
            }

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const mappedEdges = hoveredEdge ? automorphismMap[`${hoveredEdge.v1},${hoveredEdge.v2}`] : [];

                // Draw all edges
                edges.forEach(edge => {
                    const isHovered = hoveredEdge && edge.v1 === hoveredEdge.v1 && edge.v2 === hoveredEdge.v2;
                    const isMapped = mappedEdges && mappedEdges.some(mapped => 
                        (mapped[0] === edge.v1 && mapped[1] === edge.v2) || 
                        (mapped[0] === edge.v2 && mapped[1] === edge.v1)
                    );

                    let color = '#334155'; // slate-700
                    let width = 2;

                    if (isHovered) {
                        color = '#f59e0b'; // amber-500
                        width = 5;
                    } else if (isMapped) {
                        color = '#8b5cf6'; // violet-500
                        width = 4;
                    }
                    
                    drawLine(vertices[edge.v1], vertices[edge.v2], color, width);
                });

                // Draw vertices
                vertices.forEach((v, i) => {
                    ctx.beginPath();
                    ctx.arc(v.x, v.y, 12, 0, 2 * Math.PI);
                    ctx.fillStyle = '#475569'; // slate-600
                    ctx.fill();
                    ctx.strokeStyle = '#94a3b8'; // slate-400
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    ctx.fillStyle = '#f1f5f9'; // slate-100
                    ctx.font = 'bold 14px Roboto';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(v.label, v.x, v.y);
                });
            }

            function drawLine(p1, p2, color, width) {
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.strokeStyle = color;
                ctx.lineWidth = width;
                ctx.stroke();
            }
            
            function getClosestEdge(x, y) {
                let minDistance = Infinity;
                let closestEdge = null;

                edges.forEach(edge => {
                    const p1 = vertices[edge.v1];
                    const p2 = vertices[edge.v2];
                    const dist = distToSegment({ x, y }, p1, p2);
                    
                    if (dist < minDistance && dist < 15) {
                        minDistance = dist;
                        closestEdge = edge;
                    }
                });
                return closestEdge;
            }

            function distToSegment(p, v, w) {
                const l2 = (v.x - w.x)**2 + (v.y - w.y)**2;
                if (l2 === 0) return Math.sqrt((p.x - v.x)**2 + (p.y - v.y)**2);
                let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
                t = Math.max(0, Math.min(1, t));
                const projection = { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) };
                return Math.sqrt((p.x - projection.x)**2 + (p.y - projection.y)**2);
            }

            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const edge = getClosestEdge(x, y);
                if (edge !== hoveredEdge) {
                    hoveredEdge = edge;
                    if (hoveredEdge) {
                        const v1 = hoveredEdge.v1 + 1;
                        const v2 = hoveredEdge.v2 + 1;
                        const mapped = automorphismMap[`${hoveredEdge.v1},${hoveredEdge.v2}`];
                        const mappedStr = mapped ? mapped.map(p => `(${p[0]+1} ${p[1]+1})`).join('') : 'Error';
                        infoPanel.textContent = `(${v1} ${v2})  →  ${mappedStr}`;
                    } else {
                        infoPanel.textContent = '';
                    }
                    draw();
                }
            });

            window.addEventListener('resize', setup);
            setup();
        });
    </script>
</body>
</html>
